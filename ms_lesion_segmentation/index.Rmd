---
title: "MS Lesion Segmentation"
output:
  ioslides_presentation:
    widescreen: yes
    css: ../styles.css
  beamer_presentation: default
bibliography: ../refs.bib       
---

```{r setup, include=FALSE}
library(methods)
knitr::opts_chunk$set(echo = TRUE, comment = "", cache=TRUE)
```


## Goals of this tutorial

- Obtaining manual lesion segmentations is often resource intensive, so accurate and efficient methods for automatic segmentation are necessary for scalability and research progress.
- Apply OASIS [@sweeney2013oasis], an automatic lesion segmentation model, to obtain predicted lesion probability maps.
- Compare the results using the default OASIS settings to those obtained after re-training the model using our data.


```{r loading, echo=FALSE, message=FALSE}
library(ms.lesion)
library(neurobase)
library(fslr)
library(scales)
library(oasis)
tr_files = get_image_filenames_list_by_subject(group = "training", type = "coregistered")
ts_files = get_image_filenames_list_by_subject(group = "test", type = "coregistered")
tr_t1s = lapply(tr_files, function(x) readnii(x["MPRAGE"]))
tr_t2s = lapply(tr_files, function(x) readnii(x["T2"]))
tr_flairs = lapply(tr_files, function(x) readnii(x["FLAIR"]))
tr_pds = lapply(tr_files, function(x) readnii(x["PD"]))
tr_masks = lapply(tr_files, function(x) readnii(x["Brain_Mask"]))
tr_golds = lapply(tr_files, function(x) readnii(x["mask2"]))
ts_t1s = lapply(ts_files, function(x) readnii(x["MPRAGE"]))
ts_t2s = lapply(ts_files, function(x) readnii(x["T2"]))
ts_flairs = lapply(ts_files, function(x) readnii(x["FLAIR"]))
ts_pds = lapply(ts_files, function(x) readnii(x["PD"]))
ts_masks = lapply(ts_files, function(x) readnii(x["Brain_Mask"]))
```

## Visualization
- Here's the T1 volume for training subject 05 with the ‘gold standard’ manual lesion segmentation overlayed.

```{r over_show_run, echo=FALSE}
les_mask = tr_golds$training05
ortho2(tr_t1s$training05, les_mask, col.y = "orange")
```

## MS Lesion Segmentation with OASIS
- OASIS is Automated Statistical Inference for Segmentation [@sweeney2013oasis]
- The OASIS algorithm takes FLAIR, T1, T2, and PD images from patients with multiple sclerosis (MS) and produces OASIS probability maps of MS lesion presence, which can be thresholded into a binary lesion segmentation.
- OASIS uses logistic regression of the labels on the images, smoothed versions of the images, and some interaction terms

## Default OASIS Model
- The OASIS library comes with default parameters that can be used to generate probability maps for new test subjects
- Here we apply the function `oasis_predict` with the default model to obtain OASIS probability maps for the test subjects.

```{r default_predict_ts_show, eval=FALSE}
default_predict_ts = function(x){
  res = oasis_predict(
      flair=ts_flairs[[x]], t1=ts_t1s[[x]], 
      t2=ts_t2s[[x]], pd=ts_pds[[x]], 
      brain_mask=ts_masks[[x]], 
      preproc=FALSE, normalize=TRUE, 
      model=oasis::oasis_model)
  return(res)
}
default_probs_ts = lapply(1:3, default_predict_ts)
```

```{r default_predict_run, eval=TRUE, echo=FALSE}
default_ts = lapply(ts_files, 
	function(x) readnii(x["Default_OASIS"]))
```

## Vizualization
- Here's the probability map for test subject 01:

```{r viz_01, echo=FALSE}
les_mask = default_ts[[1]]
ortho2(ts_t1s$test01, les_mask)
```

## Thresholding
- To get a final estimated segmentation, we must choose a cutoff to binarize the OASIS probability maps.
- The `binary` argument in the `oasis_predict` function is FALSE by default, resulting in the output being the probability map.
- Setting `binary=TRUE` will return the thresholded version, using the input to the `threshold` argument (default = 0.16).
- In practice, we might want to use a grid search over thresholds and cross validation to choose the cutoff.

## Vizualization
- Here's the binary mask for test subject 01, using the default 0.16 threshold:

```{r viz_01, echo=FALSE}
les_mask[les_mask<.16] = 0
les_mask[les_mask!=0] = 1
ortho2(ts_t1s$test01, les_mask, col.y="orange")
```

## Default OASIS Model
- To evaluate how the default model performs, we need to compare the predictions to a gold standard.
- Let's therefore obtain OASIS probability maps for our training subjects.
- We will use the default threshold to binarize.

```{r default_predict_tr_show, eval=FALSE}
default_predict_tr = function(x){
  res = oasis_predict(
      flair=tr_flairs[[x]], t1=tr_t1s[[x]], 
      t2=tr_t2s[[x]], pd=tr_pds[[x]], 
      brain_mask=tr_masks[[x]], 
      preproc=FALSE, normalize=TRUE, 
      model=oasis::oasis_model, binary=TRUE)
  return(res)
}
default_probs_tr = lapply(1:5, default_predict_tr)
```

```{r default_predict_tr_run, eval=TRUE, echo=FALSE}
default_tr = lapply(tr_files, 
	function(x){
		img = readnii(x["Default_OASIS"])
		img[img>.16] = 1
		img[img<1] = 0
		return(img)
	})
```

## Default OASIS Model Results
- Here's the T1 volume for training subject 05 with the OASIS segmentation overlayed.

```{r over_05_run, echo=FALSE}
les_mask = default_tr[[5]]
ortho2(tr_t1s$training05, les_mask, col.y = "orange")
```

## Default OASIS Model Results
- The average dice coeffients (over the two gold standards) for the training subjects are: 0.49, 0.69, 0.43, 0.29, 0.26.

```{r table1, echo=FALSE, eval=FALSE}
dice = function(x){
	return((2*x[2,2])/(2*x[2,2] + x[1,2] + x[2,1]))
}
tbls_df = lapply(1:5, function(x) table(c(tr_golds[[x]]), c(default_tr[[x]])))
lapply(tbls_df, function(x) dice(x))
```

## Improving Results
- The default model is picking up a lot of false positives in the lower brain and spinal chord (check this)
- We might improve the results by re-training the OASIS model using our five training subjects.
- To retrain the model using new data, binary masks of gold standard lesion segmentations are needed and should be in T1 space.


## Making OASIS data frames
- OASIS requires a particular data frame format
- Includes an option to preprocess your data (`preproc`)
- Includes an option to normalize the intensities of your data using whole-brain normalization (`normalize`)
- `make_df()` below is a helper function

```{r oasis_df_show, eval=FALSE}
make_df = function(x){
  res = oasis_train_dataframe(
      flair=tr_flairs[[x]], t1=tr_t1s[[x]], t2=tr_t2s[[x]],
      pd=tr_pds[[x]], gold_standard=tr_golds[[x]], 
      brain_mask=tr_masks[[x]], 
      preproc=FALSE, normalize=TRUE, return_preproc=FALSE)
  return(res$oasis_dataframe)
}
oasis_dfs = lapply(1:5, make_df)
```

## Training OASIS 
- The function `oasis_training` takes the data frames we made and fits a logistic regression, where the outcome vector consists of all subjects' voxel-level data (top 85\% in intensity)
- The function `do.call` is a useful R function that applies the function named in the first argument to all elements of the list specified in the second argument.

```{r oasis_model_show, eval=FALSE}
model = do.call("oasis_training", oasis_dfs)
```

## OASIS model object
- `model` is an object of type `glm`
- We see the covariates used and assosicated coefficients when we print the model:

```{r oasis_model_show2}
print(model)
```

## Trained OASIS Model Results
- The average dice coeffients (over the two gold standards) for the training subjects are: 0.64, 0.71, 0.62, 0.36, 0.36.


```{r table2, echo=FALSE, eval=FALSE}
trained_tr = lapply(tr_files, 
	function(x){
		img = readnii(x["Trained_OASIS"])
		img[img>.16] = 1
		img[img<1] = 0
		return(img)
	})

tbls_tr = lapply(1:5, function(x) table(c(tr_golds[[x]]), c(trained_tr[[x]])))
lapply(tbls_tr, function(x) dice(x))
```


## References {.smaller}
