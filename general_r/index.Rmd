---
title: "General R (and Writing Images)"
output:
  ioslides_presentation:
    widescreen: yes
    css: ../styles.css
  beamer_presentation: default
bibliography: ../refs.bib       
---

```{r setup, include=FALSE}
library(methods)
knitr::opts_chunk$set(echo = TRUE, comment = "")
```

## Reading in the image

Again we will read in the `training01_01_mprage.nii.gz` file, and assign it to an object called `t1`:
```{r}
library(neurobase)
t1 = readnii("training01_01_mprage.nii.gz")
```

## Data Classes

- Numeric - numbers (e.g. 1, 3.673)
- Character - strings or words (`"hey"`, `"I'm a string"`) in either single or double quotes
- Logicals - `TRUE` or `FALSE` - all capital letters and are **not** in quotes. 

## Data Types

- `vector` - 1-dimensional object of one class (all numeric or all character)
- `matrix` - 2-dimensional object of one class
- `data.frame` - 2-dimensional object, can be multiple classes (like Excel spreadsheet)
- `array` - object of dimensions > 2 of one class.  The data in a `nifti` object is one of these (usually 3-D)
- `nifti` - an array with header information
- `list` - a general holder of things 


## Vectors

- Create a vector of numeric values and assign to variable `v`

```{r vec}
v = c(1, 4, 3, 7, 8)
```

- Subsetting (first index is `1`, not zero):
```{r vecSub}
print(v[4])
print(v[1:3])
print(v[c(1,3,5)])
```


## Matrices

- Create a 3 x 4 numeric matrix and assign to variable `m`
```{r mat}
m = matrix(1:12, nrow = 3)
```

- Subsetting - `[row,column]` format, if `row` or `column` missing then all values:
```{r matSub}
print(m[,4])
print(m[2,])
print(m[1,3])
print(m[1:2,3:4])
```

## Arrays

- Create a 3 x 4 x 3 numeric array and assign to variable `a`
```{r arr}
a = array(1:36, dim = c(3, 4, 3))
```

- Subsetting - `[x,y,z]` format:
```{r arrSub}
dim(a[,4,])
```

This will return an error!
```{r arrSub_bad, eval = FALSE}
a[,4]
```

## Operators in R

These return logical values:

- Comparison: `>`, `>=`, `<`, `<=`, `==` (equals), `!=` (not equal)
- Logical: `!` - not, `&` - and, `|` - or (a "pipe")
- `all`: test all values `TRUE` and `any` (are any)


These return numeric values:

- Arithmetic: `+`, `-`, `*`, `/`, `^` - exponents
- Standard math functions: `log`, `abs`, `sqrt`
- There are many more


## Subsetting with logicals 

You can also subsetting with logical vectors:
```{r}
v[ v > 5 ]
```

The `which` command takes a logical and gets the indices of `TRUE`:
```{r}
which(v > 5)
v[ which(v > 5) ]
```


## Subsetting with `nifti` objects: like `arrays`

The subsetting here is similar to that of arrays, so we will use the `t1`. Since it's 3-dimensions the subsetting goes to the 3rd dimension
```{r}
t1[5, 4, 3]
```

```{r, eval = FALSE}
t1[5, 4, ] # returns a vector of numbers (1-d)
t1[, 4, ] # returns a 2-d matrix
t1[1, , ] # returns a 2-d matrix
```


## Operations with `nifti` objects

These work with an image and a number (`img + 2`) or two images of the same dimensions `img1 + img2`.

- Comparison: `>`, `>=`, `<`, `<=`, `==` (equals), `!=` (not equal)
- Logical: `!` - not, `&` - and, `|` - or (a "pipe")
- Arithmetic: `+`, `-`, `*`, `/`, `^` - exponents
- Standard math functions: `log`, `abs`, `sqrt`

## Working with `nifti` objects

Again, we can use a logical operation.  Let's get the values of the `t1` greater than 400 (`head` only prints the first 6 values):

```{r}
head(t1[ t1 > 400 ])
```

## Working with `nifti` objects

The operation results in a `nifti` object, and if we look at the values, they are logical:
```{r}
class(t1 > 400)
head(t1 > 400)
```
## `which` with `nifti` objects

The `which` function works to get indices, but you can pass the `arr.ind = TRUE` argument to get "array" indices:

```{r}
head(which(t1 > 400, arr.ind = TRUE))
```

## Working with `nifti` objects: reassignment 

Subsetting can work on the left hand side of assignment too:

```{r}
t1_copy = t1
t1_copy[ t1_copy > 400] = 400 # changed these values!
max(t1_copy) # should be 400
max(t1) 
```

Note, although `t1_copy` was copied from `t1`, they are not linked - if you change values in `t1_copy`, values in `t1` are unchanged.

## Writing Images out

We now can write out this modified `t1_copy` image:
```{r}
writenii(nim = t1_copy, 
         filename = "training01_mprage_under400.nii.gz")
file.exists("training01_mprage_under400.nii.gz")
```

We have seen that `file.exists` returns `TRUE` if a file exists (similarly `dir.exists` for directories).  


## Vectorizing a `nifti`

To convert a `nifti` to a `vector`, you can simply use the `c()` function:

```{r vec_nifti, cache=FALSE}
vals = c(t1)
class(vals)
```

This is useful for making `data.frame`s (not covered here) when you want to do modeling at a voxel level.

## Histogram

From these values we can do all the standard plotting/manipulations of data.  For example, let's do a marginal density of the values:

```{r dens}
plot(density(vals))
```

## Histogram

You can also pass in a mask to most standard functions:

```{r dens_with_mask}
plot(density(t1, mask = t1 > 0))
```


## Lists

- Initialize an empty list and add two elements to it

```{r list}
l = list()
l[[1]] = v
l[[2]] = m
print(l)
```

- Subsetting uses double brackets:
```{r listSub}
print(l[[1]])
```

## Subsetting by name

If a `vector` has names, you can also put the 
- Initialize an empty list and add two elements to it

```{r named_vec}
x = c(first = 1, third = 14, second = 5)
print(x)
x[c("third")]
```

If a `list` has names, you can subset with the `$`

- Subsetting uses double brackets:
```{r named_lst}
names(l) = c("V", "m")
l$V
```

## Lists: `lapply`

With `list`s and vectors, there are `apply` functions.  These apply a function to every element of the list.  In this course, we will use:

- `lapply` - apply function and return the elements as a `list`
- `sapply` - apply function and return a "simplified" version
    - if all elements returned are a one-element vector, return a `vector`
    - if element 5 has 3 elements and element 4 has 4 elements, return a `list`
- `mapply` - takes in 2 (or more) lists and "links" the two to perform a function requiring arguments from each list 
    - passing in a list of images and the filenames to write them to

## File helpers - for constructing filenames

Use `paste` if you want to put strings together with spaces, `paste0` no spaces by default.

`file.path(directory, filename)` will paste `directory` and `filename` w/file separators (e.g. `/`)

```{r}
c(paste("img", ".nii.gz"), paste0("img", ".nii.gz"))
file.path("output_directory", paste0("img", ".nii.gz"))
```

`nii.stub` will strip off the nifti extension.  If `bn = TRUE`, it removes the directory as well:

```{r}
nii.stub(file.path("output_directory", paste0("img", ".nii.gz")))
nii.stub(file.path("output_directory", paste0("img", ".nii.gz")), bn = TRUE)
```


## Main Packages we will use

* `oro.nifti` - reading/writing NIfTI images
* `neurobase` - extends `oro.nifti` and provides helpful imaging functions
* `fslr` - wraps FSL commands to use in R
    - registration, image manipulation
* `ANTsR` - wrapper for Advanced normalization tools (ANTs) code 
    - registration, inhomogeneity correction, lots of tools
* `extrantsr` - allows `ANTsR` to work with objects from `oro.nifti` 

Data Package we will use

* `ms.lesion` - contains training/testing data of patients with multiple sclerosis (MS)
    - from the MS lesion challenge 2016 (http://iacl.ece.jhu.edu/index.php/MSChallenge)


 

## Conclusions

- We have (briefly) covered some R data classes and types to get you started
- We will be using `nifti` objects
    - They are special 3-dimensional arrays
    - Contain numbers or logicals
- We have briefly covered subsetting and image manipulation
    - more on that later



## References
